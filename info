Машина, которой управляют команды Brainfuck, состоит из упорядоченного набора ячеек и указателя текущей ячейки, напоминая ленту и головку машины Тьюринга. Кроме того, подразумевается устройство общения с внешним миром (см. команды . и ,) через поток ввода и поток вывода. 

Есть следующие команды:
	>  перейти к следующей ячейке
	<  перейти к предыдущей ячейке
	+  увеличить значение в текущей ячейке на 1
	-  уменьшить значение в текущей ячейке на 1
	[  если значение текущей ячейки ноль, перейти вперёд по тексту программы на ячейку, следующую за соответствующей ] (с учётом вложенности)
	]  если значение текущей ячейки не нуль, перейти назад по тексту программы на символ [ (с учётом вложенности)
	.  напечатать значение из текущей ячейки (в кодировке Unicod)
	,  ввести извне значение и сохранить в текущей ячейке (в кодировке Unicod)

В «классическом» Brainfuck, описанном Мюллером, размер ячейки — один байт, количество ячеек 30 000. В начальном состоянии указатель находится в крайней левой позиции, а все ячейки заполнены нулями. Увеличение/уменьшение значений ячеек происходит по модулю 256. Ввод-вывод также происходит побайтно, с учётом кодировки ASCII (то есть в результате операции ввода (,) символ 1 будет записан в текущую ячейку как число 0x31 (49), а операция вывода (.), совершённая над ячейкой, содержащей 0x41 (65), напечатает латинскую А). В других вариантах языка размер и количество ячеек может быть другим (большим). Есть версии, где значение ячеек не целочисленно (с плавающей точкой).
_______________________________________
Программа на языке Brainfuck, печатающая «Hello World!»:

 ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
_______________________________________
Особености програмирования.

Каждый начинающий программировать на Brainfuck немедленно сталкивается со следующими проблемами:
    отсутствие операции копирования значения
    отсутствие промежуточной (аккумуляторной) памяти
    отсутствие условных операторов в их привычном виде
    отсутствие привычной арифметики, операций умножения и деления
Эти проблемы могут быть решены.

Обозначим через @(k) сдвиг на k ячеек вправо, если k>0, и влево, если k<0
 Соответственно, @(k) = >…k раз…> либо <…-k раз…<  

Оператор	Значение
	релизация	(коментарий)

 zero()		обнуление текущей ячейки
   	[-]	(или [+])

 add(k)		прибавление значения ячейки n (текущей) к значению ячейки n+k
    	[ — @(k)  + @(-k)  ]	(при этом значение ячейки n теряется (обнуляется).)

 mov(k)		копирование значения ячейки n (текущей) в ячейку n+k с потерей (обнулением) значения ячейки n
   	@(k) zero() @(-k) add(k)	(то есть: @(k) [-] @(-k) [ — @(k)  + @(-k)  ])

 copy(k,t)	копирование значения ячейки n (текущей) в ячейку n+k c использованием промежуточной ячейки n+k+t,
		благодаря чему значение ячейки n не теряется (сохраняется).
   	@(k) zero() @(t) zero() @(-k-t) [ — @(k) + @(t) + @(-k-t) ] @(k+t) mov(-k-t)
	(то есть: @(k) [-] @(t) [-] @(-k-t) [ — @(k) + @(t) + @(-k-t) ] @(k+t) [ — @(-k-t) + @(k+t) ])

 ifelse(t)	если текущая ячейка>0, то выполняется условие true, если текущая ячейка=0, то выполняется 
		условие false. t-относительный номер вспомогательной ячейки.
	@(t)[-]+@(-t) [ @(t)[-]@(-t)[-] ] @(t) [ @(-t)@(t)[-] ] @(-t-1)
	( поеснение:
		@(t)[-]+@(-t) устанавливаем флаг 1 для случая else
   		[
   		здесь действия ветки true
   		@(t)[-]@(-t) устанавливаем флаг 0 для случая else
   		[-] ] @(t) [
   		@(-t)
  		здесь действия ветки false
		@(t)[-] ] @(-t-1)					)